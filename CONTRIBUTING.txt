CONTRIBUTING TO SOCNET.SE
=========================
Socnet.se can be expanded in three dimensions, adding one of the following items:

* A new ideal block
* A new goodness-of-fit measure
* A new search heuristic

This file outlines how to do this.

If updating Socnet.se, please contact Carl Nordlund (carl.nordlund@liu.se) for support and coordination! :)

Implementing novel ideal blocks
===============================
Each ideal block is represented by its own class, residing in the /DataLibrary/Blocks/ folder. Each block inherits
from the same abstract _Block.cs, that both specifies necessary and optional methods that each block class must have.

To simplify the implementation of a new ideal block, the following file is provided as a template for the class file:

_exampleBlock.cs

To create a new ideal block, it is recommended to copy this file, renaming the file and the class to a suitable name.

Important: if you give your ideal block the shorthand form 'abc', the file must be named 'abcBlock'!

Also make sure to assign it a unique isoIndex. This index is only for checking for isomorphic blockimages: as long as
each block has a unique isoIndex, that should work fine.

Follow the instructions given in the comments. Importantly: make sure to either implement the methods for determining
the partial penalty/correlation for this ideal block. Please consult the other ideal blocks for suggestions on how to
do this.

Once your ideal block class file has been created, open the following file:
BlockmodelingConstants.cs

Add the shorthand name of your new ideal block to the 'IndexToIdealBlockName' dictionary. Also add it to the
'AvailableBlocks' dictionary, making sure that it is in the lines corresponding to the goodness-of-fit functions you
implemented.


Implementing a new goodness-of-fit measure (in Blockmodeling.cs)
================================================================
It is possible to implement a new goodness-of-fit measure, though it takes a bit more work. All this work is done inside
the Blockmodeling.cs class. A good way to start is to explore how the two existing goodness-of-fit measures are
implemented, i.e. the following methods (in Blockmodeling.se):

public static BMSolution binaryHamming(Matrix matrix, BlockImage blockimage, Partition partition) { ... }

public static BMSolution nordlund2020(Matrix matrix, BlockImage blockimage, Partition partition) { ... }

As noted, these methods all take the network (Matrix), a blockimage object and an actor partition. All cells in
the blockimage are traversed, taking the corresponding clusters and calling the correct goodness-of-fit method in
the ideal block class, i.e. either getPenaltyHamming (for classical Hamming gof) or getTripletList (for weighted
correlation-based gof).

Thus, to implement a new goodness-of-fit measure, the first step is to create a new method with an identical signature.
E.g.:

public static BMSolution myGofMethod(Matrix matrix, BlockImage blockimage, Partition partition) { ... }

...where all ideal blocks in the blockimage are iterated through, and for each of the ideal blocks (testing
several for multiblocked blockimages), calling the goodness-of-fit measure in the ideal block.

The next step is to extend the Socnet.se CLI syntax for the "bminit()" command. In addition to allowing for
"hamming" and "nordlund", it must now also be possible to select 'mygof' (or hopefully a better name). To do
this, modify the Blockmodeling.InitializeSearch() method so that it also checks for 'mygof' and, if so, sets the
delegate 'gofMethod' to 'myGofMethod'. Also indicate whether this is a measure that is optimally large (like a
correlation) or small (like a Hamming distance).

Third, to register the new goodness-of-fit function, head to BlockmodelingConstants and update the following
two structures:

List<..> GofMethods: add your goodness-of-fit method ('mygof')
Dictionary<..> AvailableBlocks : create a new line (similar to 'hamming' and 'nordlund') with 'mygof', and specify the ideal blocks that
work with this goodness-of-fit measure.

Finally, with a new goodness-of-fit measure, this means that these have to be implemented in the ideal blocks as well.
Start with _Block, i.e. the abstract parent class, and add a virtual method for your goodness-of-fit measure at the
block level. These are the methods that are called by your 'myGofMethod' above.

Then, go into the specific blocks that should have your goodness-of-fit measure and override this method when applicable.
Make sure that the specific blocks in which you implement your goodness-of-fit measure are represented in the
BlockmodelingConstants.AvailableBlocks dictionary.


Implementing a new search algorithm (in Blockmodeling.cs)
=========================================================
There are currently three search heuristics implemented in Socnet.se:

public static void doExhaustiveSearch() { ... }
public static void doLjubljanaSearch() { ... }
public static void doLocalOptSearch() { ... }

Neither of these methods take any arguments: instead they work with global variables in the Blockmodeling class.

Similar to the goodness-of-fit measure, the search algorithm is specified in the InitializeSearch(..) method, which
corresponds to the CLI command 'bminit()'. To implement a new search heuristic is however more straight-forward.

First, create a new method where your search is being done:

public static void doMyNewSearch() { ... }

Utilize the global variables 'blockimages', maximizeGof, matrix and optimalSolutionsGlobal to search for a solution
The BMSolution struct is used to store temporary information about a potential solution.

Then, go back to InitializeSearch(...) and the 'bminit()' command to add the new search algorithm as an option.
As the signature of your search method is the same as the existing ones, that is all about assigning the
delegate variable to this new method.

Finally, go in to BlockmodelingConstants and add your search heuristic to the SearchTypes list.